@using MjrChess.Trainer.BlazorExtensions
@using MjrChess.Trainer.Models

@inherits MaterialDesignComponentBase

@if (Puzzle != null)
{
    <div class="mdc-card puzzleInfoCard">
        <div>
            <h2 class="mdc-typography mdc-typography--headline6">
                <ChessPieceComponent PieceType="ChessPieces.WhitePawn" File="7" /> @(Puzzle.WhitePlayer?.Name??"White Player")
                v.
                <ChessPieceComponent PieceType="ChessPieces.BlackPawn" File="7" /> @(Puzzle.BlackPlayer?.Name??"Black Player")
            </h2>
            <h3 class="mdc-typography mdc-typography--subtitle2">@Description</h3>
        </div>
        <div class="mdc-typography mdc-typography--body2">
            In this position, @(ChessFormatter.IsPieceWhite(Puzzle.PieceMoved)?"white":"black") blundered by playing <strong>@(Puzzle.IncorrectMove.ToString())</strong>.
        </div>
        <br />
        <div class="mdc-typography mdc-typography--body2">
            Can you do better? Find the best move for @(ChessFormatter.IsPieceWhite(Puzzle.PieceMoved)?"white":"black")!
        </div>
        @if (PuzzleState == PuzzleState.Solved)
        {
            <div>
                <h1 class="mdc-typography mdc-typography--headline4 puzzleMessage correctMessage">
                    <i class="material-icons" aria-hidden="true">check</i>
                    Correct
                </h1>
            </div>
        }
        @if (PuzzleState == PuzzleState.Missed)
        {
            <div>
                <h1 class="mdc-typography mdc-typography--headline4 puzzleMessage incorrectMessage">
                    <i class="material-icons md-48" aria-hidden="true">clear</i>
                    Incorrect
                </h1>
            </div>
        }
        <div class="mdc-card__actions mdc-layout-grid--align-right">
            @switch (PuzzleState)
            {
                case PuzzleState.Solved:
                case PuzzleState.Revealed:
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">replay</button>
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">skip_next</button>
                    break;
                case PuzzleState.Missed:
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">replay</button>
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">help_outline</button>
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">skip_next</button>
                    break;
                case PuzzleState.Ongoing:
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">help_outline</button>
                    <button class="mdc-icon-button mdc-card__action mdc-card__action--button material-icons pull-right">skip_next</button>
                    break;
            }
        </div>
    </div>
}

@code {
    [Parameter]
    public TacticsPuzzle? Puzzle { get; set; }

    [Parameter]
    public PuzzleState PuzzleState { get; set; }

    public string Description
    {
        get
        {
            var descriptionComponents = new[] { Puzzle?.Site, Puzzle?.GameDate?.ToString("yyyy-MM-dd") };
            return string.Join(", ", descriptionComponents.Where(s => !string.IsNullOrWhiteSpace(s)));
        }
    }
}
