@inherits ChessPuzzleBase

<div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-2-desktop mdc-layout-grid__cell--span-2-tablet mdc-layout-grid__cell--span-4-phone">
    <!-- Show a history of puzzles that have been attempted -->
    <PuzzleHistoryList CurrentPuzzle="CurrentPuzzle" History="PuzzleHistory" OnPuzzleSelect="LoadPuzzleByIdAsync" />
</div>
<div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-7-desktop mdc-layout-grid__cell--span-6-tablet mdc-layout-grid__cell--span-4-phone">
    @if(CurrentPuzzle == null)
    {
        <LoadingSpinner />
    }
    else
    {
        <!-- The chess board for displaying the puzzle, configured so that only the correct color pieces can be moved -->
        <ChessBoard 
            Engine ="PuzzleEngine" 
            UserMovableBlackPieces="!WhiteToMove" 
            UserMovableWhitePieces="WhiteToMove"/>
    }
</div>
<div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-3-desktop mdc-layout-grid__cell--span-8-tablet mdc-layout-grid__cell--span-4-phone">
    <!-- Puzzle info, including buttons to reset, reveal, or skip the puzzle -->
    <PuzzleInfo 
        Puzzle="CurrentPuzzle" 
        PuzzleState="CurrentPuzzleState" 
        PuzzleEngine="PuzzleEngine"
        OnReset="WrapActionAsTask(ResetPuzzle)" 
        OnReveal="WrapActionAsTask(RevealPuzzle)" 
        OnNext="LoadNextPuzzleAsync"/>
</div>

@code {
    bool WhiteToMove => CurrentPuzzle?.WhiteToMove ?? true;

    // Use this instead of Task.Run so that short synchronous tasks aren't queued on
    // the ThreadPool just to wrap them as Tasks.
    Func<Task> WrapActionAsTask(Action action) => () =>
    {
        action?.Invoke();
        return Task.CompletedTask;
    };
} 